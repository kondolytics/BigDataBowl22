---
title: "BUS 696 Final Project"
author: "Nicholas Kondo"
subtitle: Using NFL Player Tracking Data
output:
  html_document:
    df_print: paged
  html_notebook: default
---

```{r setup, include= FALSE}

# Please leave this code chunk as is. It makes some slight formatting changes to alter the output to be more aesthetically pleasing. 

library(knitr)

# Change the number in set seed to your own favorite number
set.seed(4)
options(width=70)
options(scipen=99)


# this sets text outputted in code chunks to small
opts_chunk$set(tidy.opts=list(width.wrap=50),tidy=TRUE, size = "vsmall")  
opts_chunk$set(message = FALSE,                                          
               warning = FALSE,
               # "caching" stores objects in code chunks and only rewrites if you change things
               cache = TRUE,                               
               # automatically downloads dependency files
               autodep = TRUE,
               # 
               cache.comments = FALSE,
               # 
               collapse = TRUE,
               # change fig.width and fig.height to change the code height and width by default
               fig.width = 5.5,  
               fig.height = 4.5,
               fig.align='center')


```

```{r setup-2, include= FALSE}

# Always print this out before your assignment
sessionInfo()
getwd()

```

<!-- ### start answering your problem set here -->
<!-- You may export your homework in either html or pdf, with the former usually being easier. 
     To export or compile your Rmd file: click above on 'Knit' then 'Knit to HTML' -->
<!-- Be sure to submit both your .Rmd file and the compiled .html or .pdf file for full credit -->

```{r setup-3, include= FALSE}

# load all your libraries in this chunk 
library(dplyr)
library(stringr)
library(ggplot2)
library(forcats)
library(here)
library(formatR)
library(readr)

# note, do not run install.packages() inside a code chunk. install them in the console outside of a code chunk. 

```


##Exploring our data##
```{r include=FALSE}

PFFScoutingData <- read_csv('/Users/nickkondo/OneDrive - Chapman University/R/NFL/Datasets/PFFScoutingData.csv')

players <- read_csv('/Users/nickkondo/OneDrive - Chapman University/R/NFL/Datasets/players.csv')

games <- read_csv('/Users/nickkondo/OneDrive - Chapman University/R/NFL/Datasets/games.csv')

plays <- read_csv('/Users/nickkondo/OneDrive - Chapman University/R/NFL/Datasets/plays.csv')

tracking2018 <- read_csv('/Users/nickkondo/OneDrive - Chapman University/R/NFL/Datasets/tracking2018.csv')

tracking2019 <- read_csv('/Users/nickkondo/OneDrive - Chapman University/R/NFL/Datasets/tracking2019.csv')

tracking2020 <- read_csv('/Users/nickkondo/OneDrive - Chapman University/R/NFL/Datasets/tracking2020.csv')

```


Let's take a look into our data and see how many NA values there are in our data set across variables.
``` {r}
sort(colSums(is.na(tracking2018)))
```


We have 555,537 NA values under a few variables including nflId, jersey number, and position.  nflID is a unique ID for every player in the NFL.  This means that we have a handful of observations where there is no player.  What is accounting for these NA values?
```{r}
table(tracking2018[is.na(tracking2018$nflId), "displayName"])
```

##Filtering Our Data set##

There are 555,537 observations where the football is being tracked rather than a player.  To clean up our data set so we only have observations of the players being tracked, let's remove the observations with 'football' as the display name.  We will also use filter so that we are returning only the frames of the 'kickoff' and 'kick_received'.  Now let's see how many  NA values we have.  
```{r}
## 2018 

kick18 <- tracking2018 %>% 
  # Filtering so the football is removed
  filter(displayName != "football") %>% 
  
  # Grouping by gameId and playId
  group_by(gameId, playId) %>% 
  
  arrange(gameId, playId, frameId) %>% 
  
  # Filtering so we only see the frames of the kickoff and kick received
  filter(event == 'kick_received' | event  == 'kickoff') 

## 2019 

kick19 <- tracking2019 %>% 
  # Filtering so the football is removed
  filter(displayName != "football") %>% 
  
  # Grouping by gameId and playId
  group_by(gameId, playId) %>% 
  
  arrange(gameId, playId, frameId) %>% 
  
  # Filtering so we only see the frames of the kickoff and kick received
  filter(event == 'kick_received' | event  == 'kickoff') 

## 2020

kick20 <- tracking2020 %>% 
  # Filtering so the football is removed
  filter(displayName != "football") %>% 
  
  # Grouping by gameId and playId
  group_by(gameId, playId) %>% 
  
  arrange(gameId, playId, frameId) %>% 
  
  # Filtering so we only see the frames of the kickoff and kick received
  filter(event == 'kick_received' | event  == 'kickoff') 

# To save vector memory, let's remove our big tracking data sets
rm(tracking2018, tracking2019, tracking2020)

head(kick18)

```

Now let's combine 2018, 2019, and 2020 and join the plays and PFF scouting tables with our tracking data.  We will use filter so we have only Kickoff plays only, and we also want to remove onside, squib kicks, and punts.  We store this object as kickoffs.  

```{r}
kick <- rbind(kick18, kick19, kick20)

# To save vector memory, let's remove our old variables 
rm(kick18, kick19, kick20)

# Combining our plays data with our tracking(kick) data
kick_plays <- inner_join(x = kick,
                         y = plays, 
                         by = c('gameId', 'playId'))

# Combining our tracking and plays data with our PFF Scounting Data
kick_plays_PFF <- inner_join(x = kick_plays, 
                             y = PFFScoutingData, 
                             by  = c('gameId', 'playId'))

# Filtering out only the kickoff play type  
kickoffs <- kick_plays_PFF %>% 
  filter(specialTeamsPlayType ==  'Kickoff') %>% 
  # We are going to keep deep, flat, and pooch kicks
  filter(kickType == 'D' | kickType == 'F' | kickType == 'P')

# Changing the character variables to factors
kickoffs <- as.data.frame(unclass(kickoffs),                     
                                  stringsAsFactors = TRUE)

rm(kick_plays, kick_plays_PFF, kick)
  
head(kickoffs)
```


##Summary Statistics##

How many unique plays and games do we have in our data set now?
```{r}
length(unique(kickoffs$playId))
length(unique(kickoffs$gameId))
```

What are the dimensions of our X and Y coordinates?
```{r}
min(kickoffs$x)
max(kickoffs$x)
min(kickoffs$y)
max(kickoffs$y)
```

##New Features

Here we are creating new features:

**yard_result** - The yard line the play results in, or the yard line the returner carried the ball to before being tackled. 

**YardResult_Over25**  -  A binary indicator if the yard resulted in the 25 yard line or more.  The 25 yard line is where the ball is placed if the play result in a touchback.  

**kickto_yardline**  - The yard line the ball was kicked to, or the yard line the player caught(or dropped) the ball

**Y_position** - The position the field a player is.  We categorize this into 4 locations:
left = left of the hash 
right = right of the hash 
center = in between the hashes 
out of bounds = not in the boundaries of the field 

**kickto_5yardBin** - The 5-yard bin that the ball was kicked to.  The yard_result variable is grouped into bin of 5 yards.  

**timestamp** The time at a given frame in HH:MM:SS 


```{r} 
kickoffs <- kickoffs %>% 
         # Creating a variable for what yard line the play resulted at 
        # 
  mutate(yard_result = (100 - yardlineNumber) - playResult,
         
         # Creating a binary variable for if the ball reached the 25 yard line or not
         YardResult_over25 = ifelse(yard_result > 25 | yard_result == 25,'1','0'),
         
         # Creating a variable for which yard line the ball was kicked to
         kickedto_yardline = 100 - (yardlineNumber + kickLength),
         
         # Creating a variable for Y position on the field
         Y_position = ifelse(y < 23.36667 & y > 0, 'left', 
                      ifelse(y > 29.96667 & y < 53.3333, 'right',
                      ifelse(y > 23.36667 & y < 53.3333, 'center', 
                      ifelse(y < 0 | y > 53.3333, "out of bounds", 'NA')))),
         
         # Creating a variable for 5-yard bins
         kickedto_5yardBin =
           ifelse(kickedto_yardline >= -10 & -5 > kickedto_yardline, "back-half endzone",
           ifelse(kickedto_yardline >= -5 & 0 > kickedto_yardline, "front-half endzone", 
           ifelse(kickedto_yardline >= 0 & 5 > kickedto_yardline, "0-5",
           ifelse(kickedto_yardline >= 5 & 10 > kickedto_yardline, "5-10",
           ifelse(kickedto_yardline >= 10 & 15 > kickedto_yardline, "10-15", 
           ifelse(kickedto_yardline >= 15 & 20 > kickedto_yardline, "15-20",
           ifelse(kickedto_yardline >= 20 & 25 > kickedto_yardline, "20-25",
           ifelse(kickedto_yardline >= 25 & 30 > kickedto_yardline, "25-30",
           ifelse(kickedto_yardline >= 30 & 35 > kickedto_yardline, "30-35",
           ifelse(kickedto_yardline >= 35 & 40 > kickedto_yardline, "35-40",
           ifelse(kickedto_yardline >= 40 & 45 > kickedto_yardline, "40-45",
           ifelse(kickedto_yardline >= 45 & 50 > kickedto_yardline, "45-50",
           ifelse(kickedto_yardline >= 50 & 55 > kickedto_yardline, "50-55",
           ifelse(kickedto_yardline >= 55 & 60 > kickedto_yardline, "55-60",
           ifelse(kickedto_yardline >= 60 & 65 > kickedto_yardline, "60-65","NA")
           )))))))))))))))

# Changing variables to factors
kickoffs <- as.data.frame(unclass(kickoffs),                     
                                  stringsAsFactors = TRUE)

# Creating a variable for time
kickoffs$timestamp <- str_sub(kickoffs$time, - 12, - 1)

kickoffs$timestamp <- sub("T"," ",kickoffs$time)
kickoffs$timestamp <- strptime(kickoffs$timestamp, format = "%Y-%m-%d %H:%M:%OS", tz = "")

glimpse(kickoffs)
```







(Old text but kept for notes)
We want to make this more actionable and into a simple yes or no decision.  On kickoffs, the returner has the decision to catch the ball and return the kick, or the decision to let the ball land in the end zone and result in a touchback.  A touchback results in the ball being placed at the 25 yard line.  If the returner expects to run the ball beyond the 25 yard line, he should make the decision to return it.  If the returner does not think he can run the ball past the 25 yard line, he should let the ball land in the end zone to receive a touchback (ball placed at 25 yard line).  Some things that influence what yard the returner gets to are how far the kick is (or where the returner catches the ball), the hang time of the kick, how fast the returner is, how far the defenders are, and much more.  To start, let's create a new feature, a binary variable 'did the returner reach beyond the 25 yard line or not.

(Old text but kept for notes)
The exact yard line a returner catches the ball may not be a great predictor of yard line result because if we separate the yard line by each yard, there are too few observations at each level. A new feature that we will create and test is 5-yard bins.  This is more actionable because when a player is looking at the sky catching a ball, he may not know what exact yard line he's standing on, but he will have a good idea of what 5 yard bin he's standing in.


Releveling the 5-Yard bins so they are in proper order.  
```{r}

# Releveling the 5-Yard bins 
kickoffs <- kickoffs %>% 
  mutate(kickedto_5yardBin = fct_relevel(kickedto_5yardBin, "back-half endzone", "front-half endzone", "0-5", "5-10", "10-15", "15-20", "20-25", "25-30", "30-35", "35-40", "40-45", "45-50", "50-55", "55-60"))

levels(kickoff_plays$kickedto_5yardBin)
```

Creating a data set `returns` using filter to get values `muffed` and `return` since there is no player on the other variables.
```{r} 
table(kickoffs$specialTeamsResult)

returns <- kickoffs %>% 
  filter(specialTeamsResult  == 'Return' | specialTeamsResult ==  'Muffed')

table(returns$specialTeamsResult)
```

# Creating Defenders (Kickoff Team) and Defender Variables

The data set is expanded so that for every player or `displayName`, there are 11 observations, where 11 defenders and their location, distance, speed, acceleration, and more variables are included.  We slice our data to return the 10 closest defenders because these are the players running down the field while the kicker usually lags behind.  

```{r}
# Creating a new variable Opposing team because we eventually want to find the distance from the opposing players, not team players

# If a player is on the away team, lets return the home team, else, let's return away
returns$opp_team <- ifelse(returns$team == 'away', 'home', 'away')

# Sanity check
table(returns$opp_team == returns$team)

# Creating a data set for the moment of the ball being caught
received <- returns %>% 
  filter(event == 'kick_received')

# Joining returns2 onto itself where team = opp_team and creating 11 rows for each player with a defender added

receivedJoin <- left_join(received,
                     received[, c("gameId", "playId", "nflId", "displayName",                                             "opp_team", "x","y","s", "a", "dis")],
                     by = c("gameId" = "gameId", "playId" = "playId", "team" =                                      "opp_team"))

# Creating a variable for distance from returner or 'ball carrier'
receivedJoin$distance <- (((receivedJoin$x.x - receivedJoin$x.y)^2) + 
                       (receivedJoin$y.x - receivedJoin$y.y)^2)^.5

# Using filter to return the only the returner 
receivedJoin <- receivedJoin  %>% 
  filter(receivedJoin$nflId.x == receivedJoin$returnerId) 
  

# We are grabbing the 10 closest defenders because the kicker should be removed from the play when evaluating the kickoff team

# Average Yardline
# Average 
received10 <- receivedJoin %>% group_by(displayName.x, gameId, playId) %>% slice_min(distance, n = 5) %>% 
  # Creating average distance, speed, and acceleration variables
  mutate(KoTeamAvgX = mean(x.x),
         KoTeamAvgDist  = mean(distance),
         KoTeamAvgSpeed  = mean(s.y),
         KoTeamAvgA = mean(a.y))

glimpse(received10)

```

Let's roll this data back up 

```{r}
clean <- received10 %>% 
  select(time, x.x, y.x, event, displayName.x, nflId.x, returnerId, position, gameId, 
         playId, frameId, playDescription, kickReturnYardage, yard_result,
         YardResult_over25,kickedto_yardline, kickedto_5yardBin, Y_position, KoTeamAvgX,
         KoTeamAvgDist,KoTeamAvgSpeed, KoTeamAvgA, specialTeamsPlayType, 
         specialTeamsResult, kickType, hangTime, kickDirectionIntended,  
         kickDirectionActual, returnDirectionIntended, returnDirectionActual, 
         kickoffReturnFormation) 

clean2 <- unique(clean)
```

Let's take a look at some scatter plots of our variables 
```{r}

library(ggthemes)

ggplot(data = clean2, aes(x = kickedto_yardline, y = kickReturnYardage)) + 
  geom_point() + 
  theme_excel(base_size = 16) +
  labs( x = 'Yard Line Kicked To', y = 'Kick Return Yardage')

ggplot(data = clean, aes(x = KoTeamAvgDist, y = kickReturnYardage)) + 
  geom_point() +
  theme_excel(base_size = 16) + 
  labs( x = 'Avg Distance of Defenders', y = 'Kick Return Yardage')
  
ggplot(data = clean2, aes(x = KoTeamAvgSpeed, y = kickReturnYardage)) + 
  geom_point() +
  theme_excel(base_size = 16) +
  labs( x = 'Avg Speed of Defenders', y = 'Kick Return Yardage')
  
ggplot(data = clean2, aes(x = KoTeamAvgA, y = kickReturnYardage)) + 
  geom_point() +
  theme_excel(base_size = 16) +
  labs( x = 'Avg Speed^2 of Defenders', y = 'Kick Return Yardage')

```
After seeing this I think I'm going to take out plays that were returned more than 50 yards because they are outliers and may be skewing our data.  

```{r}

#Removing outliers

clean2 <- clean2 %>% 
  filter(yard_result < 50)

```


##Building a Linear Model##
```{r}
library('sjPlot')

mod1 <- lm(kickReturnYardage ~ kickedto_yardline + KoTeamAvgDist + KoTeamAvgA + Y_position + kickType + specialTeamsResult,
           data = clean2)


summary(mod1)
tab_model(mod1)

summary(clean2$KoTeamAvgSpeed)

# There's negative values in kicked_toyardline so we cant log it 

```

### Generating Predictions

```{r}
library('rsample')

# Creating a split with 75% of the data in the training set
df_split <- initial_split(clean2, prop = .75)
df_train <- training(df_split)
df_test <- testing(df_split)

mod2 <- lm(kickReturnYardage ~ kickedto_yardline + KoTeamAvgDist + Y_position + kickType + specialTeamsResult,
data  = clean2)

# Generating in-sample (training) predictions
preds_test <- predict(mod2, newdata = df_test)

# Generating out-of-sample (testing) predictions
preds_train <- predict(mod2, newdata = df_train)

# Mean Squared Error
get_rmse <- function(true, predictions){
  sqrt(mean((true - predictions)^2))
}


get_rmse(df_train$yard_result, preds_train)
get_rmse(df_test$yard_result, preds_test)

# Test Error > Training Error means model is overfit 
# Test Error < Training Error means model is underfit
# We want test error to ~ training 





```






Here we are creating plot to show the frequency of where balls were kicked to.  We can see that the most balls were kicked the the back half of the end zone, and the frequency drops as we move out of the end zone.  The reason for this is because the kicker's objective is to kick the ball as far down field as possible.

```{r}

logit <- glm(YardResult_over25 ~ kickedto_yardline + hangTime + specialTeamsResult + average_kickoff_dist + average_kickoff_speed, 
           family = binomial,
           data = returnsJoin3)

summary(logit)
```

When I return: Add special teams catch type to 


```{r}

ggplot(kickoffs, aes(x = kickedto_5yardBin)) +
  geom_histogram(stat = "count") + 
  coord_flip() + 
  xlab('5-Yard Bin Kicked To') +
  ylab('frequency') + 
  theme(axis.text=element_text(size=12),
        axis.title = element_text(size=12))

```


We only want to use the plays where the returner made the decision to return it.  `Downed`, `Fair  Catch`, `Out of Bounds`, and `Touchback` don't have any outcome to evaluate.  `Muffed` means the player did not catch it cleanly but the player still returned the ball so we will leave that variable in.

```{r} 
table(kickoffs$specialTeamsResult)

returns <- kickoffs %>% 
  filter(specialTeamsResult  == 'Return' | specialTeamsResult ==  'Muffed')

table(returns$specialTeamsResult)
```

Here is the frequency of balls returned.  Take a look at the `back-half endzone`, despite the most balls kicked here, players rarely return this ball.  This is because the players would rather take a touchback (ball placed at 25 yard line) rather than returning the ball from the back half of the endzone.  

```{r}

ggplot(returns, aes(x = kickedto_5yardBin)) +
  geom_histogram(stat = "count") + 
  coord_flip() + 
  xlab('5-Yard Bin Kicked To') +
  ylab('frequency') + 
  theme(axis.text=element_text(size=12),
        axis.title = element_text(size=12))
```

## Summary Statistics

For every single kickoff, the ball is usually kicked to the -1.189 yard line.  Which is approximately one yard into the end zone.

For every single kickoff return  (excludes touchbacks), the average yard result was 25.84, slightly above where the ball would be placed if the play resulted in a touchback.  
```{r}

summary(kickoffs$kickedto_yardline)

summary(returns$yard_result)

```

Here is the variable 5 yard bin kicked to compared to the yard result.  We can see that where the ball is kicked is correlated in some way with the yard result.  This aligns with our hypothesis that the further the ball is kicked, the smaller the yard line the player will likely end up.  One thing to notice is when the ball is kicked in the back of the end zone, the highest yard line a returner ran to was the 50 yard line. (100 = score) 
```{r}

ggplot(returns, aes(x = kickedto_5yardBin, y = yard_result)) +
  geom_boxplot() +
  coord_flip()  +
  xlab('5-Yard Bin Kicked To') +
  ylab('Yard Result') + 
  theme(axis.text=element_text(size=14),
        axis.title = element_text(size=14))

```

```{r}

summary(clean2$KoTeamAvgDist)

```


We want to create an expected yards variable given the circumstances when the moment the ball is caught.  

Next steps 

Creating Defense Distance Variable 
Creating Defense Acceleration variable 

Logistic Model 25>

Linear Model

Random Forest 

Presentation 

Evaluating the model - How well did we predict 

-------

Alter some new features, and test out some more stuff to find a really high predicting model 



